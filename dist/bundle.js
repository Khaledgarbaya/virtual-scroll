!function(e){function t(e){var t=document.getElementsByTagName("head")[0],n=document.createElement("script");n.type="text/javascript",n.charset="utf-8",n.src=d.p+""+e+"."+E+".hot-update.js",t.appendChild(n)}function n(e){if("undefined"==typeof XMLHttpRequest)return e(new Error("No browser support"));try{var t=new XMLHttpRequest,n=d.p+""+E+".hot-update.json";t.open("GET",n,!0),t.timeout=1e4,t.send(null)}catch(i){return e(i)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)e(new Error("Manifest request to "+n+" timed out."));else if(404===t.status)e();else if(200!==t.status&&304!==t.status)e(new Error("Manifest request to "+n+" failed."));else{try{var i=JSON.parse(t.responseText)}catch(r){return void e(r)}e(null,i)}}}function i(e){function t(e,t){"ready"===w&&s("prepare"),k++,d.e(e,function(){function n(){k--,"prepare"===w&&(T[e]||c(e),0===k&&0===O&&u())}try{t.call(null,i)}finally{n()}})}var n=I[e];if(!n)return d;var i=function(t){return n.hot.active?I[t]?(I[t].parents.indexOf(e)<0&&I[t].parents.push(e),n.children.indexOf(t)<0&&n.children.push(t)):S=[e]:(console.warn("[HMR] unexpected require("+t+") from disposed module "+e),S=[]),d(t)};for(var r in d)Object.prototype.hasOwnProperty.call(d,r)&&(p?Object.defineProperty(i,r,function(e){return{configurable:!0,enumerable:!0,get:function(){return d[e]},set:function(t){d[e]=t}}}(r)):i[r]=d[r]);return p?Object.defineProperty(i,"e",{enumerable:!0,value:t}):i.e=t,i}function r(e){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],active:!0,accept:function(e,n){if("undefined"==typeof e)t._selfAccepted=!0;else if("function"==typeof e)t._selfAccepted=e;else if("object"==typeof e)for(var i=0;i<e.length;i++)t._acceptedDependencies[e[i]]=n;else t._acceptedDependencies[e]=n},decline:function(e){if("undefined"==typeof e)t._selfDeclined=!0;else if("number"==typeof e)t._declinedDependencies[e]=!0;else for(var n=0;n<e.length;n++)t._declinedDependencies[e[n]]=!0},dispose:function(e){t._disposeHandlers.push(e)},addDisposeHandler:function(e){t._disposeHandlers.push(e)},removeDisposeHandler:function(e){var n=t._disposeHandlers.indexOf(e);n>=0&&t._disposeHandlers.splice(n,1)},check:l,apply:h,status:function(e){return e?void C.push(e):w},addStatusHandler:function(e){C.push(e)},removeStatusHandler:function(e){var t=C.indexOf(e);t>=0&&C.splice(t,1)},data:_[e]};return t}function s(e){w=e;for(var t=0;t<C.length;t++)C[t].call(null,e)}function o(e){var t=+e+""===e;return t?+e:e}function l(e,t){if("idle"!==w)throw new Error("check() is only allowed in idle status");"function"==typeof e?(b=!1,t=e):(b=e,t=t||function(e){if(e)throw e}),s("check"),n(function(e,n){if(e)return t(e);if(!n)return s("idle"),void t(null,null);N={},L={},T={};for(var i=0;i<n.c.length;i++)L[n.c[i]]=!0;g=n.h,s("prepare"),v=t,y={};var r=0;c(r),"prepare"===w&&0===k&&0===O&&u()})}function a(e,t){if(L[e]&&N[e]){N[e]=!1;for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(y[n]=t[n]);0===--O&&0===k&&u()}}function c(e){L[e]?(N[e]=!0,O++,t(e)):T[e]=!0}function u(){s("ready");var e=v;if(v=null,e)if(b)h(b,e);else{var t=[];for(var n in y)Object.prototype.hasOwnProperty.call(y,n)&&t.push(o(n));e(null,t)}}function h(t,n){function i(e){for(var t=[e],n={},i=t.slice();i.length>0;){var s=i.pop(),e=I[s];if(e&&!e.hot._selfAccepted){if(e.hot._selfDeclined)return new Error("Aborted because of self decline: "+s);if(0===s)return;for(var o=0;o<e.parents.length;o++){var l=e.parents[o],a=I[l];if(a.hot._declinedDependencies[s])return new Error("Aborted because of declined dependency: "+s+" in "+l);t.indexOf(l)>=0||(a.hot._acceptedDependencies[s]?(n[l]||(n[l]=[]),r(n[l],[s])):(delete n[l],t.push(l),i.push(l)))}}}return[t,n]}function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];e.indexOf(i)<0&&e.push(i)}}if("ready"!==w)throw new Error("apply() is only allowed in ready status");"function"==typeof t?(n=t,t={}):t&&"object"==typeof t?n=n||function(e){if(e)throw e}:(t={},n=n||function(e){if(e)throw e});var l={},a=[],c={};for(var u in y)if(Object.prototype.hasOwnProperty.call(y,u)){var h=o(u),f=i(h);if(!f){if(t.ignoreUnaccepted)continue;return s("abort"),n(new Error("Aborted because "+h+" is not accepted"))}if(f instanceof Error)return s("abort"),n(f);c[h]=y[h],r(a,f[0]);for(var h in f[1])Object.prototype.hasOwnProperty.call(f[1],h)&&(l[h]||(l[h]=[]),r(l[h],f[1][h]))}for(var p=[],m=0;m<a.length;m++){var h=a[m];I[h]&&I[h].hot._selfAccepted&&p.push({module:h,errorHandler:I[h].hot._selfAccepted})}s("dispose");for(var v=a.slice();v.length>0;){var h=v.pop(),b=I[h];if(b){for(var C={},O=b.hot._disposeHandlers,k=0;k<O.length;k++){var T=O[k];T(C)}_[h]=C,b.hot.active=!1,delete I[h];for(var k=0;k<b.children.length;k++){var N=I[b.children[k]];if(N){var L=N.parents.indexOf(h);L>=0&&N.parents.splice(L,1)}}}}for(var h in l)if(Object.prototype.hasOwnProperty.call(l,h))for(var b=I[h],P=l[h],k=0;k<P.length;k++){var x=P[k],L=b.children.indexOf(x);L>=0&&b.children.splice(L,1)}s("apply"),E=g;for(var h in c)Object.prototype.hasOwnProperty.call(c,h)&&(e[h]=c[h]);var j=null;for(var h in l)if(Object.prototype.hasOwnProperty.call(l,h)){for(var b=I[h],P=l[h],A=[],m=0;m<P.length;m++){var x=P[m],T=b.hot._acceptedDependencies[x];A.indexOf(T)>=0||A.push(T)}for(var m=0;m<A.length;m++){var T=A[m];try{T(l)}catch(R){j||(j=R)}}}for(var m=0;m<p.length;m++){var D=p[m],h=D.module;S=[h];try{d(h)}catch(R){if("function"==typeof D.errorHandler)try{D.errorHandler(R)}catch(R){j||(j=R)}else j||(j=R)}}return j?(s("fail"),n(j)):(s("idle"),void n(null,a))}function d(t){if(I[t])return I[t].exports;var n=I[t]={exports:{},id:t,loaded:!1,hot:r(t),parents:S,children:[]};return e[t].call(n.exports,n,n.exports,i(t)),n.loaded=!0,n.exports}var f=this.webpackHotUpdate;this.webpackHotUpdate=function(e,t){a(e,t),f&&f(e,t)};var p=!1;try{Object.defineProperty({},"x",{get:function(){}}),p=!0}catch(m){}var v,y,g,b=!0,E="d1f76105e55d0ec7c17b",_={},S=[],C=[],w="idle",O=0,k=0,T={},N={},L={},I={};return d.m=e,d.c=I,d.p="/static/",d.h=function(){return E},i(0)(0)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(1);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _VirtualScroll = __webpack_require__(2);\n\nvar _VirtualScroll2 = _interopRequireDefault(_VirtualScroll);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar listSource = [];\nfor (var i = 0; i < 3000; i++) {\n  listSource.push({ itemId: i });\n}var virtualScroll1 = new _VirtualScroll2.default({\n  // DOMnode the list will be renderd inside\n  root: document.getElementsByClassName('list')[0],\n  // itemHeight\n  itemHeight: 50,\n  // ARRAY containg all the objects to be displayed inside the list\n  source: listSource,\n\n  /**\n   * FUNCTION to be called while creating a single item\n   *\n   * @param  {object}  itemNodes       empty object provided by the list logic\n   * @param  {DOMnode} itemContainer   item container provided by the list logic\n   */\n  createItemFn: function createItemFn(itemNodes, itemContainer) {\n    // EXAMPLE\n    itemNodes.text1 = document.createElement('span');\n    itemNodes.text1.style.height = '50px';\n    itemNodes.text1.style.borderTop = '1px solid black';\n    itemNodes.text1.style.borderBottom = '1px solid black';\n    itemNodes.text1.style.width = '100%';\n    itemContainer.appendChild(itemNodes.text1);\n  },\n\n  /**\n   * FUNCTION to be called while updating a single item\n   *\n   * @param  {object}  itemNodes       object previously filled by createItemFn()\n   * @param  {DOMnode} itemContainer   item container provided by the list logic\n   * @param  {object}  itemData        object inside listSource array at the current index\n   */\n  updateItemFn: function updateItemFn(itemNodes, itemContainer, itemData) {\n    // EXAMPLE\n    itemNodes.text1.innerHTML = \"ITEM Number \" + itemData.itemId;\n  }\n});\nvar virtualScroll2 = new _VirtualScroll2.default({\n  // DOMnode the list will be renderd inside\n  root: document.getElementsByClassName('list')[1],\n\n  itemHeight: 70,\n\n  // ARRAY containg all the objects to be displayed inside the list\n  source: listSource,\n\n  /**\n   * FUNCTION to be called while creating a single item\n   *\n   * @param  {object}  itemNodes       empty object provided by the list logic\n   * @param  {DOMnode} itemContainer   item container provided by the list logic\n   */\n  createItemFn: function createItemFn(itemNodes, itemContainer) {\n    // EXAMPLE\n    itemNodes.text1 = document.createElement('span');\n\n    itemNodes.text1.style.height = '70px';\n    itemNodes.text1.style.borderTop = '1px solid black';\n    itemNodes.text1.style.borderBottom = '1px solid black';\n    itemNodes.text1.style.width = '100%';\n    itemContainer.appendChild(itemNodes.text1);\n  },\n\n  /**\n   * FUNCTION to be called while updating a single item\n   *\n   * @param  {object}  itemNodes       object previously filled by createItemFn()\n   * @param  {DOMnode} itemContainer   item container provided by the list logic\n   * @param  {object}  itemData        object inside listSource array at the current index\n   */\n  updateItemFn: function updateItemFn(itemNodes, itemContainer, itemData) {\n    // EXAMPLE\n    // update itemNodes.text1 with itemData.itemId\n    itemNodes.text1.innerHTML = \"ITEM Number \" + itemData.itemId;\n  }\n});\n\nwindow.list = virtualScroll1;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VerticalScroller = __webpack_require__(3);\n\nvar _VerticalScroller2 = _interopRequireDefault(_VerticalScroller);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VirtualScroll = function () {\n  /**\n   * constructor - VirtualScroll\n   *\n   * @param  {object} config\n   * {\n   *  // DOMnode the list will be renderd inside\n   *  root: document.getElementsByClassName('NAME_THE_CONTAINER_WHATEVER_YOU_LIKE')[0],\n   *  // ARRAY containg all the objects to be displayed inside the list\n   *  source: listSource,\n   *  //FUNCTION to be called while creating a single item\n   *    itemNodes empty object provided by the list logic\n   *    itemContainer   item container provided by the list logic\n   *  createItemFn: (itemNodes, itemContainer) =>{},\n   *\n   * //FUNCTION to be called while updating a single item\n   *   //itemNodes       object previously filled by createItemFn()\n   *  //itemContainer   item container provided by the list logic\n   *  //itemData        object inside listSource array at the current index\n   * updateItemFn: (itemNodes, itemContainer, itemData) => {},\n   * }\n   */\n\n  function VirtualScroll(config) {\n    _classCallCheck(this, VirtualScroll);\n\n    this.config = {};\n    this.info = { scrollTop: 0, direction: 1, height: 1, isScrolling: false };\n    this.config.root = config && config.root ? config.root : document.createElement('div');\n    this.config.source = config && config.source ? config.source : [];\n    this.config.createItemFn = config && config.createItemFn ? config.createItemFn : null;\n    this.config.updateItemFn = config && config.updateItemFn ? config.updateItemFn : null;\n    this.rootElement = null;\n    // setup the container\n\n    this.config.scroller = config && config.scroller ? config.scroller : new _VerticalScroller2.default(this.config.root, this.scroll.bind(this));\n\n    // TODO try to get dynamic itemHeight\n    this.totalRows = this.config.source.length;\n    this.itemHeight = config && config.itemHeight ? config.itemHeight : 50;\n    this.visibleItemsCount = Math.ceil(this.config.root.offsetHeight / this.itemHeight);\n    this.cachedItemsLen = this.visibleItemsCount * 3;\n    this.setupContainer();\n    this.renderChunk(this.rootElement, 0);\n    this.scrollerElement = this.createScroller(this.totalRows * this.itemHeight);\n    this.info.height = this.totalRows * this.itemHeight; // estimated for now\n    var bottom = this.info.height - (this.visibleItemsCount - 1) * this.itemHeight;\n    this.config.scroller.setDimensions(0, bottom);\n    this.rootElement.appendChild(this.scrollerElement);\n    this.lastRepaintY = 0;\n    this.maxBuffer = this.visibleItemsCount * this.itemHeight;\n    this.lastScrolled = 0;\n    this.rmNodeInterval = setInterval(this.remoDirtyNodes.bind(this), 300);\n    this.bindEvents();\n  }\n\n  _createClass(VirtualScroll, [{\n    key: 'remoDirtyNodes',\n    value: function remoDirtyNodes() {\n      if (Date.now() - this.lastScrolled > 100) {\n        var badNodes = this.rootElement.querySelectorAll('[data-rm=\"1\"]');\n        for (var i = 0, l = badNodes.length; i < l; i++) {\n          this.rootElement.removeChild(badNodes[i]);\n        }\n      }\n    }\n  }, {\n    key: 'bindEvents',\n    value: function bindEvents() {\n      this.config.scroller.addEventListener('scroll-start', this.onScrollBegin.bind(this));\n      this.config.scroller.addEventListener('scroll-end', this.onScrollEnd.bind(this));\n    }\n  }, {\n    key: 'onScrollBegin',\n    value: function onScrollBegin(data) {\n      this.info.isScrolling = true;\n      this.info.direction = data.direction;\n    }\n  }, {\n    key: 'onScrollEnd',\n    value: function onScrollEnd() {\n      this.info.isScrolling = false;\n    }\n  }, {\n    key: 'setupContainer',\n    value: function setupContainer() {\n      this.rootElement = document.createElement('div');\n      this.rootElement.style.width = this.config.root.clientWidth + 'px';\n      this.rootElement.style.height = this.config.root.clientHeight + 'px';\n\n      this.config.root.style.overflow = 'hidden';\n      this.config.root.style.position = 'relative';\n      this.config.root.style.padding = 0;\n      this.config.root.style.border = '1px solid black';\n\n      this.config.root.appendChild(this.rootElement);\n    }\n  }, {\n    key: 'createScroller',\n    value: function createScroller(h) {\n      var scroller = document.createElement('div');\n      scroller.style.opacity = 0;\n      scroller.style.position = 'absolute';\n      scroller.style.top = 0;\n      scroller.style.left = 0;\n      scroller.style.width = '1px';\n      scroller.style.height = h + 'px';\n      return scroller;\n    }\n  }, {\n    key: 'renderChunk',\n    value: function renderChunk(node, from) {\n      var finalItem = from + this.cachedItemsLen;\n      if (finalItem > this.totalRows) {\n        finalItem = this.totalRows;\n      }\n      // Append all the new rows in a document fragment that we will later append to\n      // the parent node\n      var fragment = document.createDocumentFragment();\n      for (var i = from; i < finalItem; i++) {\n        this.createRow(i, fragment);\n      }\n\n      // Hide and mark obsolete nodes for deletion.\n      for (var j = 1, l = node.childNodes.length; j < l; j++) {\n        if (this.scrollerElement !== node.childNodes[j]) {\n          node.childNodes[j].style.display = 'none';\n          node.childNodes[j].setAttribute('data-rm', '1');\n        }\n      }\n      node.appendChild(fragment);\n    }\n  }, {\n    key: 'createRow',\n    value: function createRow(index, container) {\n      var item = this.config.source[index];\n      if (this.config.createItemFn) {\n        var emptyObject = {};\n        this.config.createItemFn(emptyObject, container);\n        this.config.updateItemFn(emptyObject, container, item);\n        var nodeItem = container.lastChild;\n        nodeItem.classList.add('vrow');\n        nodeItem.style.position = 'absolute';\n        nodeItem.style.top = index * this.itemHeight + 'px';\n      }\n    }\n  }, {\n    key: 'scroll',\n    value: function scroll(position) {\n      //Update top of the root element\n      // translation is faster than chaning top\n      // for more info: http://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/\n      this.info.scrollTop = -position;\n\n      // translateZ(0) is to trick the browser to use the GPU for the animation\n      // so we end up with smoother animation\n      var t = 'translateY(' + -position + 'px) translateZ(0)';\n      var s = this.rootElement.style;\n      s['transform'] = t;\n      s['webkitTransform'] = t;\n      s['mozTransform'] = t;\n      s['msTransform'] = t;\n\n      if (!this.lastRepaintY || Math.abs(position - this.lastRepaintY) > this.maxBuffer) {\n        var first = parseInt(position / this.itemHeight) - this.visibleItemsCount;\n        this.renderChunk(this.rootElement, first < 0 ? 0 : first);\n        this.lastRepaintY = position;\n      }\n      this.lastScrolled = Date.now();\n    }\n    /*Public API*/\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      this.setupContainer();\n      this.renderChunk(this.rootElement, 0);\n      var bottom = this.itemHeight * this.totalRows - (this.visibleItemsCount - 1) * this.itemHeight;\n      this.config.scroller.setDimensions(0, bottom);\n    }\n  }, {\n    key: 'setSource',\n    value: function setSource(listSource) {\n      this.config.source = listSource;\n      this.refresh();\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.config.scroller.destroy();\n      clearInterval(this.rmNodeInterval);\n    }\n  }, {\n    key: 'remove',\n    value: function remove() {\n      this.destroy();\n      this.config.root.removeChild(this.rootElement);\n    }\n  }, {\n    key: 'addEventListener',\n    value: function addEventListener(event, callback) {\n      this.config.scroller.addEventListener(event, callback);\n    }\n  }, {\n    key: 'removeEventListener',\n    value: function removeEventListener(event, callback) {\n      this.config.scroller.removeEventListener(event, callback);\n    }\n  }, {\n    key: 'scrollTop',\n    value: function scrollTop(duration) {\n      this.scrollTo(0, duration);\n      this.info.direction = -1;\n    }\n  }, {\n    key: 'scrollBottom',\n    value: function scrollBottom(duration) {\n      var bottom = this.itemHeight * this.totalRows - (this.visibleItemsCount - 1) * this.itemHeight;\n      this.scrollTo(bottom, duration);\n      this.info.direction = 1;\n      this.info.scrollTop = -bottom;\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo(position, duration) {\n      this.info.direction = position > this.info.scrollTop ? -1 : 1;\n      var animate = duration && duration !== 0;\n      this.config.scroller.dispatchScrollStart(this.info.direction);\n      this.config.scroller.scrollTo(position, animate, duration);\n    }\n  }]);\n\n  return VirtualScroll;\n}();\n\nexports.default = VirtualScroll;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/VirtualScroll.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/VirtualScroll.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ScrollStore = __webpack_require__(4);\n\nvar _ScrollStore2 = _interopRequireDefault(_ScrollStore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SCROLLING_TIME_CONSTANT = 525;\n\nvar VerticalScroller = function () {\n  function VerticalScroller(scrollContainer, scrollCallback) {\n    _classCallCheck(this, VerticalScroller);\n\n    this.scrollContainer = scrollContainer;\n    this.scrollCallback = scrollCallback;\n\n    // init variables\n    this.timestamp = 0;\n    this.minOffset = 0;\n    this.maxOffset = Number.MAX_SAFE_INTEGER;\n    this.frame = 0;\n    this.velocity = 0;\n    this.amplitude = 0;\n    this.pressed = 0;\n    this.reference = 0;\n    this.offset = 0;\n    this.target = 0;\n    this.touchPositions = [];\n    this.bindEvents();\n  }\n\n  _createClass(VerticalScroller, [{\n    key: 'bindEvents',\n    value: function bindEvents() {\n      // rebinding the event handler to this\n      this.tap = this.tap.bind(this);\n      this.drag = this.drag.bind(this);\n      this.release = this.release.bind(this);\n\n      if (this.scrollContainer && this.scrollContainer.addEventListener) {\n        this.scrollContainer.addEventListener('touchstart', this.tap);\n        this.scrollContainer.addEventListener('touchmove', this.drag);\n        this.scrollContainer.addEventListener('touchend', this.release);\n        this.scrollContainer.addEventListener('mousedown', this.tap);\n        this.scrollContainer.addEventListener('mousemove', this.drag);\n        this.scrollContainer.addEventListener('mouseup', this.release);\n      }\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this.scrollContainer && this.scrollContainer.addEventListener) {\n        this.scrollContainer.removeEventListener('touchstart', this.tap);\n        this.scrollContainer.removeEventListener('touchmove', this.drag);\n        this.scrollContainer.removeEventListener('touchend', this.release);\n        this.scrollContainer.removeEventListener('mousedown', this.tap);\n        this.scrollContainer.removeEventListener('mousemove', this.drag);\n        this.scrollContainer.removeEventListener('mouseup', this.release);\n      }\n      this.removeAllListener();\n      this.scrollContainer = null;\n      this.scrollCallback = null;\n    }\n    // check what type of event we received and get the right position out of it\n\n  }, {\n    key: 'getYPosition',\n    value: function getYPosition(e) {\n      // touch event\n      if (e.targetTouches && e.targetTouches.length >= 1) {\n        return e.targetTouches[0].clientY;\n      }\n      // mouse event\n      return e.clientY;\n    }\n  }, {\n    key: 'scroll',\n    value: function scroll(position) {\n      this.offset = position;\n      this.scrollCallback(position);\n      _ScrollStore2.default.set('type', 'on-scroll');\n      // the direction will be set by the scroll start\n      _ScrollStore2.default.emitChange('on-scroll');\n    }\n  }, {\n    key: 'autoScroll',\n    value: function autoScroll() {\n      var elapsed = void 0,\n          delta = void 0,\n          newOffset = void 0;\n      if (this.amplitude) {\n        elapsed = Date.now() - this.timestamp;\n        delta = this.amplitude * Math.exp(-elapsed / SCROLLING_TIME_CONSTANT);\n        newOffset = this.target - delta;\n        if (newOffset < this.minOffset) {\n          if (this.target - delta >= this.minOffset - 2) {\n            this.scroll(this.minOffset);\n            return;\n          }\n          this.bounce(true);\n        } else if (newOffset > this.maxOffset) {\n          if (this.target - delta <= this.maxOffset + 2) {\n            this.scroll(this.maxOffset);\n            return;\n          }\n          this.bounce(false);\n        } else if (delta > 2 || delta < -2) {\n          this.scroll(this.target - delta);\n          requestAnimationFrame(this.autoScroll.bind(this));\n        } else {\n          this.scroll(this.target);\n          this.dispatchScrollEndEvent();\n        }\n      }\n    }\n  }, {\n    key: 'dispatchScrollEndEvent',\n    value: function dispatchScrollEndEvent() {\n      _ScrollStore2.default.set('type', 'scroll-end');\n      _ScrollStore2.default.emitChange('scroll-end');\n    }\n  }, {\n    key: 'dispatchScrollStart',\n    value: function dispatchScrollStart(direction) {\n      _ScrollStore2.default.set('type', 'scroll-start');\n      _ScrollStore2.default.set('direction', direction);\n      _ScrollStore2.default.emitChange('scroll-start');\n    }\n  }, {\n    key: 'bounce',\n    value: function bounce(top) {\n      var finalDestination = top ? this.minOffset : this.maxOffset,\n          isBouncingBack = top && this.amplitude > 0 || !top && this.amplitude < 0;\n\n      if (this.amplitude === 0) {\n        return;\n      }\n      var elapsed = Date.now() - this.timestamp;\n      var delta = this.amplitude * Math.exp(-elapsed / (this.target === finalDestination ? 125 : SCROLLING_TIME_CONSTANT));\n      if (isBouncingBack && Math.abs(delta) < 2) {\n        this.scroll(top ? this.minOffset : this.maxOffset);\n        this.dispatchScrollEndEvent();\n        return;\n      }\n      this.scroll(this.target - delta);\n\n      if (isBouncingBack) {\n        if (this.target !== finalDestination) {\n          this.target = finalDestination;\n          this.amplitude = this.target - this.offset;\n          this.timestamp = new Date();\n        }\n      } else {\n        this.target = finalDestination - (finalDestination - this.target) * 0.1;\n        this.amplitude = this.target - this.offset;\n      }\n\n      requestAnimationFrame(function () {\n        this.bounce(top);\n      }.bind(this));\n    }\n  }, {\n    key: 'tap',\n    value: function tap(e) {\n      this.pressed = true;\n      this.reference = this.getYPosition(e);\n\n      this.velocity = this.amplitude = 0;\n      this.frame = this.offset;\n      this.timestamp = Date.now();\n      this.recordTouches(e);\n      e.preventDefault && e.preventDefault();\n      e.stopPropagation && e.stopPropagation();\n    }\n  }, {\n    key: 'drag',\n    value: function drag(e) {\n      var y = void 0,\n          delta = void 0,\n          scaleFactor = this.offset < this.minOffset || this.offset > this.maxOffset ? 0.5 : 1;\n      if (this.pressed) {\n        this.recordTouches(e);\n        y = this.getYPosition(e);\n        delta = this.reference - y;\n        if (delta > 2 || delta < -2) {\n          this.reference = y;\n          this.scroll(this.offset + delta * scaleFactor);\n        }\n      }\n      e.preventDefault && e.preventDefault();\n      e.stopPropagation && e.stopPropagation();\n    }\n  }, {\n    key: 'recordTouches',\n    value: function recordTouches(e) {\n      var touches = e.touches || [{ pageX: e.pageX, pageY: e.pageY }],\n          timestamp = e.timeStamp,\n          currentTouchTop = touches[0].pageY;\n\n      if (touches.length === 2) {\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      }\n\n      this.touchPositions.push({ offset: currentTouchTop, timestamp: timestamp });\n      if (this.touchPositions.length > 60) {\n        this.touchPositions.splice(0, 30);\n      }\n    }\n  }, {\n    key: 'release',\n    value: function release(e) {\n      this.pressed = false;\n      var endPos = this.touchPositions.length - 1;\n      var startPos = endPos - 1;\n      // Move pointer to position measured 100ms ago\n      for (var i = endPos - 1; i > 0 && this.touchPositions[i].timestamp > this.touchPositions[endPos].timestamp - 100; i -= 1) {\n        startPos = i;\n      }\n      var elapsed = this.touchPositions[endPos].timestamp - (this.touchPositions[startPos] && this.touchPositions[startPos].timestamp) || 0;\n      var delta = this.touchPositions[endPos].offset - (this.touchPositions[startPos] && this.touchPositions[startPos].offset) || 0;\n      var v = -1000 * delta / (1 + elapsed);\n\n      this.dispatchScrollStart(delta > 0 ? 1 : -1);\n\n      this.velocity = 0.8 * v + 0.2 * this.velocity;\n      this.amplitude = 1.0 * this.velocity;\n      this.target = Math.round(this.offset + this.amplitude);\n      this.timestamp = Date.now();\n      requestAnimationFrame(this.autoScroll.bind(this));\n\n      e.preventDefault && e.preventDefault();\n      e.stopPropagation && e.stopPropagation();\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo(y, animate, duration) {\n      var maxAnimateDelta = duration || 4000;\n      if (animate) {\n        if (y - this.offset > maxAnimateDelta) {\n          this.offset = y - maxAnimateDelta;\n        } else if (this.offset - y > maxAnimateDelta) {\n          this.offset = y + maxAnimateDelta;\n        }\n\n        this.amplitude = y - this.offset;\n        this.target = y;\n        this.timestamp = Date.now();\n        requestAnimationFrame(this.autoScroll.bind(this));\n      } else {\n        this.amplitude = 0;\n        this.scroll(y);\n      }\n    }\n  }, {\n    key: 'changeScrollPosition',\n    value: function changeScrollPosition(y) {\n      this.scroll(y);\n    }\n  }, {\n    key: 'setDimensions',\n    value: function setDimensions(min, max) {\n      this.minOffset = min;\n      this.maxOffset = max;\n    }\n  }, {\n    key: 'addEventListener',\n    value: function addEventListener(type, listener) {\n      _ScrollStore2.default.on(type, listener);\n    }\n  }, {\n    key: 'removeEventListener',\n    value: function removeEventListener(type, listener) {\n      _ScrollStore2.default.removeListener(type, listener);\n    }\n  }, {\n    key: 'removeAllListener',\n    value: function removeAllListener() {\n      _ScrollStore2.default.removeAllListeners('scroll-end');\n      _ScrollStore2.default.removeAllListeners('scroll-start');\n      _ScrollStore2.default.removeAllListeners('on-scroll');\n    }\n  }]);\n\n  return VerticalScroller;\n}();\n\nexports.default = VerticalScroller;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/VerticalScroller.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/VerticalScroller.js?")},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ScrollStore = function (_EventEmitter) {\n  _inherits(ScrollStore, _EventEmitter);\n\n  function ScrollStore() {\n    _classCallCheck(this, ScrollStore);\n\n    // this is not allowed before super\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ScrollStore).call(this));\n\n    _this.data = { type: \'SCROLL_BEGIN\', direction: 0 };\n    _this.setMaxListeners(10);\n    return _this;\n  }\n\n  _createClass(ScrollStore, [{\n    key: \'get\',\n    value: function get(key) {\n      return this.data[key];\n    }\n  }, {\n    key: \'set\',\n    value: function set(key, value) {\n      return this.data[key] = value;\n    }\n  }, {\n    key: \'emitChange\',\n    value: function emitChange(type) {\n      this.emit(type, this.data);\n    }\n  }]);\n\n  return ScrollStore;\n}(_events.EventEmitter);\n\nexports.default = new ScrollStore();\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/store/ScrollStore.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/store/ScrollStore.js?');
},function(module,exports){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/events/events.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/events/events.js?")}]);